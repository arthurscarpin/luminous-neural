from typing import Type, TypeVar, Generic, List, Optional

from pydantic import BaseModel
from sqlalchemy.orm import Session

from app.core.logger import logger
from app.core.sql_database import Base

T = TypeVar("T", bound=Base)
Schema = TypeVar("Schema", bound=BaseModel)


# --- Base Repository for CRUD ---
class BaseRepository(Generic[T, Schema]):
    """Generic repository providing CRUD operations for SQLAlchemy models using Pydantic Schemas.

    This repository enforces that all create and update operations use validated Pydantic Schemas,
    ensuring data consistency and type safety.

    Attributes:
        model (Type[T]): The SQLAlchemy model class this repository manages.
        session (Session): SQLAlchemy database session used for operations.
    """

    def __init__(self, model: Type[T], session: Session):
        """
        Initialize the repository with a SQLAlchemy model and database session.

        Args:
            model (Type[T]): The SQLAlchemy model class to be managed by this repository.
        """
        self.model = model
        self.session = session

    def create(self, obj_in: Schema) -> T:
        """
        Create a new record in the database using a Pydantic Schema.

        Args:
            obj_in (Schema): A Pydantic schema containing validated fields for the new record.

        Returns:
            T: The newly created SQLAlchemy model instance with updated database state (including autogenerated fields).
        """
        logger.debug('Creating a new %s with data: %s', self.model.__name__, obj_in.model_dump())
        obj = self.model(**obj_in.model_dump())
        self.session.add(obj)
        self.session.commit()
        self.session.refresh(obj)
        logger.debug('%s created with ID: %s', self.model.__name__, obj.id)
        return obj

    def get_all(self) -> List[T]:
        """
        Retrieve all records of the model from the database with status=True.

        Returns:
            List[T]: A list of all model instances where status is True.
        """
        logger.debug('Retrieving all %s records from the database', self.model.__name__)
        query = self.session.query(self.model)
        
        if hasattr(self.model, 'status'):
            query = query.filter(getattr(self.model, 'status'))
        
        results = query.all()
        logger.debug('Retrieved %d %s records', len(results), self.model.__name__)
        return results

    def get_by_id(self, id: int) -> Optional[T]:
        """
        Retrieve a single record by its primary key, considering only active records (status=True).

        Args:
            id (int): The primary key of the record to retrieve.

        Returns:
            Optional[T]: The model instance if found and active; otherwise, None.
        """
        logger.debug('Retrieving %s record with ID: %d (only active)', self.model.__name__, id)
        query = self.session.query(self.model).filter(self.model.id == id)
        
        if hasattr(self.model, 'status'):
            query = query.filter(getattr(self.model, 'status') == True)  # noqa: E712
        
        result = query.first()
        if result:
            logger.debug('%s record with ID %d found and active', self.model.__name__, id)
        else:
            logger.debug('%s record with ID %d not found or inactive', self.model.__name__, id)
        return result

    def update(self, obj: T, obj_in: BaseModel) -> T:
        """
        Update an existing record with values provided by a Pydantic Schema.

        Only fields explicitly set in the schema will be updated (`exclude_unset=True`).
        Only active records (status=True) can be updated.

        Args:
            obj (T): The SQLAlchemy model instance to update.
            obj_in (Schema): A Pydantic schema containing the fields to update.

        Raises:
            ValueError: If the record is inactive (status=False) and cannot be updated.

        Returns:
            T: The updated SQLAlchemy model instance with refreshed database state.
        """
        if hasattr(obj, 'status') and not getattr(obj, 'status'):
            logger.warning('Cannot update %s record with ID %s because it is inactive', obj.__class__.__name__, getattr(obj, 'id', None))
            raise ValueError(f"Cannot update inactive {obj.__class__.__name__} record with ID {getattr(obj, 'id', None)}")

        update_data = obj_in.model_dump(exclude_unset=True)
        logger.debug('Updating %s record with ID %s using data: %s', obj.__class__.__name__, getattr(obj, 'id', None), update_data)
        
        for key, value in update_data.items():
            setattr(obj, key, value)
        
        self.session.commit()
        self.session.refresh(obj)
        logger.debug('%s record with ID %s updated successfully', obj.__class__.__name__, getattr(obj, 'id', None))
        return obj

    def delete(self, obj: T) -> None:
        """
        Delete a record from the database.

        Args:
            obj (T): The SQLAlchemy model instance to delete.

        Returns:
            None
        """
        logger.debug('Deleting %s record with ID: %s', obj.__class__.__name__, getattr(obj, 'id', None))
        self.session.delete(obj)
        self.session.commit()
        logger.debug('%s record with ID %s deleted successfully', obj.__class__.__name__, getattr(obj, 'id', None))

    def logical_delete(self, obj: T) -> None:
        """
        Perform a logical (soft) deletion of a database record.

        This method sets the `status` attribute to False instead of physically removing
        the record from the database. It preserves the record for historical or audit purposes.

        Args:
            obj (T): The SQLAlchemy model instance to logically delete.

        Notes:
            - The model must have a `status` attribute for this operation to succeed.
            - If the `status` attribute is missing, a warning will be logged and the operation will be skipped.
        """
        if hasattr(obj, 'status'):
            logger.debug(
                'Logically deleting %s record with ID: %s', 
                obj.__class__.__name__, 
                getattr(obj, 'id', None)
            )
            setattr(obj, 'status', False)
            self.session.commit()
            logger.debug(
                '%s record with ID %s logically deleted', 
                obj.__class__.__name__, 
                getattr(obj, 'id', None)
            )
        else:
            logger.warning(
                '%s record with ID %s does not have a status attribute. Cannot logically delete.', 
                obj.__class__.__name__, 
                getattr(obj, 'id', None)
            )
